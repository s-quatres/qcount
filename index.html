<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Music Beat Counter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: white;
        }

        .container {
            max-width: 500px;
            width: 100%;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .subtitle {
            text-align: center;
            margin-bottom: 20px;
            opacity: 0.9;
            font-size: 0.9rem;
        }

        .beat-indicator {
            width: 180px;
            height: 180px;
            margin: 0 auto 20px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 4px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4rem;
            font-weight: bold;
            transition: all 0.1s ease;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }

        .beat-indicator.pulse {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.6);
            box-shadow: 0 0 40px rgba(255, 255, 255, 0.5);
        }

        .beat-indicator.waiting {
            border-color: rgba(255, 204, 0, 0.6);
        }

        /* Volume meter */
        .volume-container {
            margin-bottom: 20px;
        }

        .volume-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin-bottom: 5px;
            opacity: 0.8;
        }

        .volume-meter {
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .volume-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4cd964, #ffcc00, #ff3b30);
            border-radius: 4px;
            transition: width 0.05s ease;
        }

        .volume-threshold {
            position: absolute;
            top: 0;
            height: 100%;
            width: 2px;
            background: white;
            opacity: 0.8;
        }

        /* Mode selector */
        .mode-selector {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .mode-button {
            padding: 12px 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        }

        .mode-button:active {
            transform: scale(0.98);
        }

        .mode-button.active {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        .mode-button .mode-name {
            display: block;
            margin-bottom: 2px;
        }

        .mode-button .mode-desc {
            font-size: 0.7rem;
            opacity: 0.7;
            font-weight: normal;
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 15px 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .info-row:last-child {
            margin-bottom: 0;
        }

        .info-label {
            font-size: 0.85rem;
            opacity: 0.8;
        }

        .info-value {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .status-stopped {
            background: rgba(255, 255, 255, 0.2);
        }

        .status-waiting {
            background: rgba(255, 204, 0, 0.3);
            border: 1px solid rgba(255, 204, 0, 0.6);
        }

        .status-listening {
            background: rgba(76, 217, 100, 0.3);
            border: 1px solid rgba(76, 217, 100, 0.6);
        }

        .status-error {
            background: rgba(255, 69, 58, 0.3);
            border: 1px solid rgba(255, 69, 58, 0.6);
        }

        .control-button {
            width: 100%;
            padding: 18px;
            font-size: 1.1rem;
            font-weight: 600;
            border: none;
            border-radius: 16px;
            background: white;
            color: #667eea;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
            -webkit-tap-highlight-color: transparent;
        }

        .control-button:active {
            transform: scale(0.98);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .control-button.listening {
            background: #ff3b30;
            color: white;
        }

        .instructions {
            text-align: center;
            margin-top: 15px;
            font-size: 0.8rem;
            opacity: 0.7;
            line-height: 1.4;
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.5rem;
            }

            .beat-indicator {
                width: 140px;
                height: 140px;
                font-size: 3rem;
            }

            .mode-button {
                padding: 10px 6px;
                font-size: 0.8rem;
            }

            .info-value {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Beat Counter</h1>
        <p class="subtitle">Detect beats and count along</p>

        <div class="beat-indicator" id="beatIndicator">
            <span id="currentCount">-</span>
        </div>

        <!-- Volume meter -->
        <div class="volume-container" id="volumeContainer" style="display: none;">
            <div class="volume-label">
                <span>Volume</span>
                <span id="volumePercent">0%</span>
            </div>
            <div class="volume-meter">
                <div class="volume-bar" id="volumeBar"></div>
                <div class="volume-threshold" id="volumeThreshold" style="left: 15%;"></div>
            </div>
        </div>

        <!-- Mode selector -->
        <div class="mode-selector">
            <button class="mode-button active" data-mode="simple">
                <span class="mode-name">Simple</span>
                <span class="mode-desc">Clear, simple beats</span>
            </button>
            <button class="mode-button" data-mode="swing">
                <span class="mode-name">Swing</span>
                <span class="mode-desc">Jazz & swing music</span>
            </button>
            <button class="mode-button" data-mode="percussion">
                <span class="mode-name">Percussion</span>
                <span class="mode-desc">Drums & snare focus</span>
            </button>
            <button class="mode-button" data-mode="bass">
                <span class="mode-name">Bass</span>
                <span class="mode-desc">Bass & kick focus</span>
            </button>
        </div>

        <div class="info-panel">
            <div class="info-row">
                <span class="info-label">Status</span>
                <span class="status-badge status-stopped" id="statusBadge">Stopped</span>
            </div>
            <div class="info-row">
                <span class="info-label">BPM</span>
                <span class="info-value" id="bpmValue">--</span>
            </div>
            <div class="info-row">
                <span class="info-label">Time Signature</span>
                <span class="info-value" id="timeSignature">--</span>
            </div>
        </div>

        <button class="control-button" id="controlButton">Start Listening</button>

        <p class="instructions">
            Select a detection mode, then tap Start. Play music near your device.
            Detection begins when volume exceeds the threshold.
        </p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/meyda@5.6.0/dist/web/meyda.min.js"></script>
    <script>
        class BeatCounter {
            constructor() {
                this.isListening = false;
                this.isActive = false; // Actually detecting beats (above volume threshold)
                this.audioContext = null;
                this.microphone = null;
                this.analyzer = null;
                this.meydaAnalyzer = null;

                // Detection mode
                this.mode = 'simple';
                this.modeConfigs = {
                    simple: {
                        bufferSize: 512,
                        features: ['rms', 'energy'],
                        thresholdMultiplier: 1.5,
                        minBeatInterval: 0.2,
                        useSpectralFlux: false
                    },
                    swing: {
                        bufferSize: 1024,
                        features: ['rms', 'energy', 'spectralFlux', 'spectralCentroid'],
                        thresholdMultiplier: 1.3,
                        minBeatInterval: 0.15,
                        useSpectralFlux: true,
                        swingTolerance: 0.3 // Allow more timing variation
                    },
                    percussion: {
                        bufferSize: 256,
                        features: ['rms', 'energy', 'spectralFlux', 'spectralCentroid'],
                        thresholdMultiplier: 1.8,
                        minBeatInterval: 0.1,
                        useSpectralFlux: true,
                        highFreqFocus: true
                    },
                    bass: {
                        bufferSize: 2048,
                        features: ['rms', 'energy', 'spectralCentroid'],
                        thresholdMultiplier: 1.4,
                        minBeatInterval: 0.25,
                        useSpectralFlux: false,
                        lowFreqFocus: true
                    }
                };

                // Volume threshold
                this.volumeThreshold = 0.02; // Actual RMS threshold (quite low)
                this.currentVolume = 0;
                this.maxObservedVolume = 0.1; // Track max for better scaling

                // Beat detection state
                this.energyHistory = [];
                this.spectralFluxHistory = [];
                this.onsetTimes = [];
                this.beatIntervals = [];
                this.currentBPM = 0;
                this.lastBeatTime = 0;
                this.beatThreshold = 0;

                // For frequency-focused detection
                this.frequencyData = null;
                this.lowBandEnergy = [];
                this.highBandEnergy = [];

                // Time signature detection
                this.beatStrengths = [];
                this.detectedTimeSignature = 4;
                this.currentBeatInMeasure = 0;

                // Voice synthesis
                this.synth = window.speechSynthesis;

                // UI elements
                this.controlButton = document.getElementById('controlButton');
                this.statusBadge = document.getElementById('statusBadge');
                this.beatIndicator = document.getElementById('beatIndicator');
                this.currentCount = document.getElementById('currentCount');
                this.bpmValue = document.getElementById('bpmValue');
                this.timeSignatureEl = document.getElementById('timeSignature');
                this.volumeContainer = document.getElementById('volumeContainer');
                this.volumeBar = document.getElementById('volumeBar');
                this.volumePercent = document.getElementById('volumePercent');
                this.volumeThresholdEl = document.getElementById('volumeThreshold');
                this.modeButtons = document.querySelectorAll('.mode-button');

                this.bindEvents();
            }

            bindEvents() {
                this.controlButton.addEventListener('click', () => {
                    if (this.isListening) {
                        this.stop();
                    } else {
                        this.start();
                    }
                });

                // Mode selection
                this.modeButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        if (this.isListening) return; // Don't change mode while listening

                        this.modeButtons.forEach(b => b.classList.remove('active'));
                        button.classList.add('active');
                        this.mode = button.dataset.mode;
                    });
                });
            }

            async start() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });

                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.microphone = this.audioContext.createMediaStreamSource(stream);

                    // Create analyzer for frequency data
                    this.analyzer = this.audioContext.createAnalyser();
                    this.analyzer.fftSize = 2048;
                    this.analyzer.smoothingTimeConstant = 0.8;
                    this.frequencyData = new Uint8Array(this.analyzer.frequencyBinCount);

                    this.microphone.connect(this.analyzer);

                    // Get mode config
                    const config = this.modeConfigs[this.mode];

                    // Initialize Meyda with mode-specific settings
                    this.meydaAnalyzer = Meyda.createMeydaAnalyzer({
                        audioContext: this.audioContext,
                        source: this.microphone,
                        bufferSize: config.bufferSize,
                        featureExtractors: config.features,
                        callback: (features) => this.processAudio(features)
                    });

                    this.meydaAnalyzer.start();

                    this.isListening = true;
                    this.isActive = false;
                    this.volumeContainer.style.display = 'block';
                    this.volumeThresholdEl.style.left = (this.volumeThreshold * 100) + '%';
                    this.updateUI();
                    this.updateStatus('Waiting for music...', 'waiting');
                    this.beatIndicator.classList.add('waiting');

                    // Disable mode buttons while listening
                    this.modeButtons.forEach(b => b.style.opacity = '0.5');

                } catch (error) {
                    console.error('Error accessing microphone:', error);
                    this.updateStatus('Mic access denied', 'error');
                    alert('Please allow microphone access to use this app.');
                }
            }

            stop() {
                if (this.meydaAnalyzer) {
                    this.meydaAnalyzer.stop();
                }

                if (this.microphone && this.microphone.mediaStream) {
                    this.microphone.mediaStream.getTracks().forEach(track => track.stop());
                }

                if (this.audioContext) {
                    this.audioContext.close();
                }

                // Reset state
                this.resetState();

                this.isListening = false;
                this.isActive = false;
                this.volumeContainer.style.display = 'none';
                this.updateUI();
                this.updateStatus('Stopped', 'stopped');
                this.currentCount.textContent = '-';
                this.bpmValue.textContent = '--';
                this.timeSignatureEl.textContent = '--';
                this.beatIndicator.classList.remove('waiting');

                // Re-enable mode buttons
                this.modeButtons.forEach(b => b.style.opacity = '1');
            }

            resetState() {
                this.energyHistory = [];
                this.spectralFluxHistory = [];
                this.onsetTimes = [];
                this.beatIntervals = [];
                this.beatStrengths = [];
                this.lowBandEnergy = [];
                this.highBandEnergy = [];
                this.currentBPM = 0;
                this.currentBeatInMeasure = 0;
                this.lastBeatTime = 0;
                this.maxObservedVolume = 0.1;
            }

            processAudio(features) {
                if (!features || !this.isListening) return;

                const config = this.modeConfigs[this.mode];
                const currentTime = this.audioContext.currentTime;

                // Calculate current volume (RMS)
                this.currentVolume = features.rms || 0;
                this.updateVolumeDisplay();

                // Check volume threshold
                if (this.currentVolume < this.volumeThreshold) {
                    if (this.isActive) {
                        // Was active, now below threshold
                        this.updateStatus('Waiting for music...', 'waiting');
                        this.beatIndicator.classList.add('waiting');
                        this.isActive = false;
                    }
                    return;
                }

                // Above threshold - start/continue detection
                if (!this.isActive) {
                    this.isActive = true;
                    this.updateStatus('Detecting...', 'listening');
                    this.beatIndicator.classList.remove('waiting');
                    this.resetState(); // Fresh start when music begins
                }

                // Get frequency data for band-specific analysis
                this.analyzer.getByteFrequencyData(this.frequencyData);

                // Detect beat based on mode
                let beatDetected = false;
                let beatStrength = 0;

                if (config.lowFreqFocus) {
                    // Bass mode: focus on low frequencies (0-200Hz)
                    const result = this.detectBassbeat(features, currentTime, config);
                    beatDetected = result.detected;
                    beatStrength = result.strength;
                } else if (config.highFreqFocus) {
                    // Percussion mode: focus on high frequencies and transients
                    const result = this.detectPercussionBeat(features, currentTime, config);
                    beatDetected = result.detected;
                    beatStrength = result.strength;
                } else if (config.useSpectralFlux) {
                    // Swing mode: use spectral flux for complex rhythms
                    const result = this.detectSwingBeat(features, currentTime, config);
                    beatDetected = result.detected;
                    beatStrength = result.strength;
                } else {
                    // Simple mode: energy-based detection
                    const result = this.detectSimpleBeat(features, currentTime, config);
                    beatDetected = result.detected;
                    beatStrength = result.strength;
                }

                if (beatDetected) {
                    this.onBeatDetected(currentTime, beatStrength);
                }
            }

            detectSimpleBeat(features, currentTime, config) {
                const energy = features.energy;

                this.energyHistory.push(energy);
                if (this.energyHistory.length > 100) {
                    this.energyHistory.shift();
                }

                const avgEnergy = this.energyHistory.reduce((a, b) => a + b, 0) / this.energyHistory.length;
                const threshold = avgEnergy * config.thresholdMultiplier;

                const detected = energy > threshold &&
                    (currentTime - this.lastBeatTime) > config.minBeatInterval;

                return { detected, strength: energy };
            }

            detectSwingBeat(features, currentTime, config) {
                const energy = features.energy;
                const spectralFlux = features.spectralFlux || 0;

                // Track both energy and spectral flux
                this.energyHistory.push(energy);
                this.spectralFluxHistory.push(spectralFlux);

                if (this.energyHistory.length > 150) {
                    this.energyHistory.shift();
                }
                if (this.spectralFluxHistory.length > 150) {
                    this.spectralFluxHistory.shift();
                }

                // Calculate adaptive thresholds
                const avgEnergy = this.energyHistory.reduce((a, b) => a + b, 0) / this.energyHistory.length;
                const avgFlux = this.spectralFluxHistory.reduce((a, b) => a + b, 0) / this.spectralFluxHistory.length;

                // Swing detection uses combined energy + spectral flux
                // Lower threshold to catch syncopated beats
                const energyThreshold = avgEnergy * (config.thresholdMultiplier - 0.2);
                const fluxThreshold = avgFlux * 1.2;

                // Detect beat if either energy OR spectral flux is high enough
                const energyPeak = energy > energyThreshold;
                const fluxPeak = spectralFlux > fluxThreshold;
                const timeSinceLastBeat = currentTime - this.lastBeatTime;

                // More tolerant timing for swing - allow slightly early/late beats
                const minInterval = config.minBeatInterval;
                const detected = (energyPeak || fluxPeak) && timeSinceLastBeat > minInterval;

                // Combine energy and flux for beat strength
                const combinedStrength = (energy + spectralFlux * 0.5);

                return { detected, strength: combinedStrength };
            }

            detectPercussionBeat(features, currentTime, config) {
                // Focus on high frequencies (drums, cymbals, snare)
                const highFreqStart = Math.floor(this.frequencyData.length * 0.3);
                const highFreqEnd = Math.floor(this.frequencyData.length * 0.8);

                let highEnergy = 0;
                for (let i = highFreqStart; i < highFreqEnd; i++) {
                    highEnergy += this.frequencyData[i];
                }
                highEnergy /= (highFreqEnd - highFreqStart);

                // Also use spectral flux for transient detection
                const spectralFlux = features.spectralFlux || 0;

                this.highBandEnergy.push(highEnergy);
                this.spectralFluxHistory.push(spectralFlux);

                if (this.highBandEnergy.length > 80) {
                    this.highBandEnergy.shift();
                }
                if (this.spectralFluxHistory.length > 80) {
                    this.spectralFluxHistory.shift();
                }

                const avgHighEnergy = this.highBandEnergy.reduce((a, b) => a + b, 0) / this.highBandEnergy.length;
                const avgFlux = this.spectralFluxHistory.reduce((a, b) => a + b, 0) / this.spectralFluxHistory.length;

                const highThreshold = avgHighEnergy * config.thresholdMultiplier;
                const fluxThreshold = avgFlux * 2.0; // Higher threshold for sharper transients

                const detected = (highEnergy > highThreshold || spectralFlux > fluxThreshold) &&
                    (currentTime - this.lastBeatTime) > config.minBeatInterval;

                return { detected, strength: highEnergy + spectralFlux };
            }

            detectBassbeat(features, currentTime, config) {
                // Focus on low frequencies (bass, kick drum)
                const lowFreqEnd = Math.floor(this.frequencyData.length * 0.1); // ~0-200Hz

                let lowEnergy = 0;
                for (let i = 0; i < lowFreqEnd; i++) {
                    lowEnergy += this.frequencyData[i];
                }
                lowEnergy /= lowFreqEnd;

                this.lowBandEnergy.push(lowEnergy);
                if (this.lowBandEnergy.length > 60) {
                    this.lowBandEnergy.shift();
                }

                const avgLowEnergy = this.lowBandEnergy.reduce((a, b) => a + b, 0) / this.lowBandEnergy.length;
                const threshold = avgLowEnergy * config.thresholdMultiplier;

                const detected = lowEnergy > threshold &&
                    (currentTime - this.lastBeatTime) > config.minBeatInterval;

                return { detected, strength: lowEnergy };
            }

            updateVolumeDisplay() {
                // Track max observed volume for better scaling
                if (this.currentVolume > this.maxObservedVolume) {
                    this.maxObservedVolume = this.currentVolume;
                }

                // Scale volume relative to max observed (with minimum floor)
                const scaledVolume = this.currentVolume / Math.max(this.maxObservedVolume, 0.05);
                const volumePercent = Math.min(100, scaledVolume * 100);

                // Update threshold indicator position relative to the scale
                const thresholdPercent = (this.volumeThreshold / Math.max(this.maxObservedVolume, 0.05)) * 100;
                this.volumeThresholdEl.style.left = Math.min(thresholdPercent, 50) + '%';

                this.volumeBar.style.width = volumePercent + '%';
                this.volumePercent.textContent = Math.round(volumePercent) + '%';
            }

            onBeatDetected(time, strength) {
                if (this.lastBeatTime > 0) {
                    const interval = time - this.lastBeatTime;
                    this.beatIntervals.push(interval);

                    if (this.beatIntervals.length > 20) {
                        this.beatIntervals.shift();
                    }

                    this.updateBPM();
                }

                this.lastBeatTime = time;

                // Track beat strength for time signature detection
                this.beatStrengths.push(strength);
                if (this.beatStrengths.length > 32) {
                    this.beatStrengths.shift();
                }

                if (this.beatStrengths.length >= 12) {
                    this.detectTimeSignature();
                }

                // Increment beat counter
                this.currentBeatInMeasure++;
                if (this.currentBeatInMeasure > this.detectedTimeSignature) {
                    this.currentBeatInMeasure = 1;
                }

                this.visualizeBeat();
                this.speakCount(this.currentBeatInMeasure);
            }

            updateBPM() {
                if (this.beatIntervals.length < 4) return;

                // Remove outliers (intervals that are way off)
                const sorted = [...this.beatIntervals].sort((a, b) => a - b);
                const q1 = sorted[Math.floor(sorted.length * 0.25)];
                const q3 = sorted[Math.floor(sorted.length * 0.75)];
                const iqr = q3 - q1;
                const validIntervals = sorted.filter(i => i >= q1 - iqr * 1.5 && i <= q3 + iqr * 1.5);

                if (validIntervals.length < 3) return;

                const median = validIntervals[Math.floor(validIntervals.length / 2)];
                const bpm = 60 / median;

                // Smooth BPM
                if (this.currentBPM === 0) {
                    this.currentBPM = bpm;
                } else {
                    this.currentBPM = this.currentBPM * 0.85 + bpm * 0.15;
                }

                // Clamp to reasonable range
                this.currentBPM = Math.max(40, Math.min(220, this.currentBPM));

                this.bpmValue.textContent = Math.round(this.currentBPM);
            }

            detectTimeSignature() {
                if (this.beatStrengths.length < 12) return;

                const scores = {
                    3: this.scoreTimeSignature(3),
                    4: this.scoreTimeSignature(4),
                    6: this.scoreTimeSignature(6),
                    8: this.scoreTimeSignature(8)
                };

                let bestSignature = 4;
                let bestScore = scores[4];

                for (const [sig, score] of Object.entries(scores)) {
                    if (score > bestScore) {
                        bestScore = score;
                        bestSignature = parseInt(sig);
                    }
                }

                if (bestScore > 0.2) {
                    this.detectedTimeSignature = bestSignature;
                    this.timeSignatureEl.textContent = `${bestSignature}/4`;
                }
            }

            scoreTimeSignature(beatsPerMeasure) {
                let score = 0;
                let measures = 0;
                const recentBeats = this.beatStrengths.slice(-24);

                for (let i = 0; i < recentBeats.length - beatsPerMeasure + 1; i += beatsPerMeasure) {
                    const measureBeats = recentBeats.slice(i, i + beatsPerMeasure);
                    if (measureBeats.length < beatsPerMeasure) break;

                    // Normalize beat strengths within measure
                    const maxStrength = Math.max(...measureBeats);
                    const normalized = measureBeats.map(b => b / maxStrength);

                    // First beat should be strongest (or close to it)
                    const firstBeatRank = normalized.filter(b => b >= normalized[0]).length;
                    if (firstBeatRank <= 2) {
                        score += 1;
                    }

                    measures++;
                }

                return measures > 0 ? score / measures : 0;
            }

            visualizeBeat() {
                this.currentCount.textContent = this.currentBeatInMeasure;
                this.beatIndicator.classList.add('pulse');

                setTimeout(() => {
                    this.beatIndicator.classList.remove('pulse');
                }, 120);
            }

            speakCount(count) {
                if (this.synth.speaking) {
                    this.synth.cancel();
                }

                const utterance = new SpeechSynthesisUtterance(count.toString());
                utterance.rate = 1.8;
                utterance.volume = 0.9;
                utterance.pitch = 1.0;

                this.synth.speak(utterance);
            }

            updateUI() {
                if (this.isListening) {
                    this.controlButton.textContent = 'Stop';
                    this.controlButton.classList.add('listening');
                } else {
                    this.controlButton.textContent = 'Start Listening';
                    this.controlButton.classList.remove('listening');
                }
            }

            updateStatus(text, type) {
                this.statusBadge.textContent = text;
                this.statusBadge.className = 'status-badge status-' + type;
            }
        }

        window.addEventListener('load', () => {
            new BeatCounter();
        });
    </script>
</body>
</html>
