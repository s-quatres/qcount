<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>8-Count Beat Counter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: white;
        }

        .container {
            max-width: 500px;
            width: 100%;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .subtitle {
            text-align: center;
            margin-bottom: 20px;
            opacity: 0.9;
            font-size: 0.9rem;
        }

        .beat-indicator {
            width: 180px;
            height: 180px;
            margin: 0 auto 20px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 4px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4rem;
            font-weight: bold;
            transition: transform 0.08s ease, background 0.08s ease;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }

        .beat-indicator.pulse {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.6);
        }

        .beat-indicator.accent {
            background: rgba(255, 215, 0, 0.4);
            border-color: rgba(255, 215, 0, 0.8);
        }

        .beat-indicator.waiting {
            border-color: rgba(255, 204, 0, 0.6);
        }

        /* Beat dots */
        .phrase-display {
            display: flex;
            justify-content: center;
            gap: 6px;
            margin-bottom: 20px;
        }

        .beat-dot {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
            transition: all 0.1s ease;
        }

        .beat-dot.current {
            background: rgba(255, 255, 255, 0.6);
            transform: scale(1.2);
        }

        .beat-dot.accent-beat {
            border: 2px solid rgba(255, 215, 0, 0.8);
        }

        /* Sliders */
        .slider-container {
            margin-bottom: 15px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            margin-bottom: 6px;
            opacity: 0.9;
        }

        .slider-value {
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        /* Volume meter */
        .volume-container {
            margin-bottom: 15px;
        }

        .volume-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.75rem;
            margin-bottom: 5px;
            opacity: 0.8;
        }

        .volume-meter {
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
        }

        .volume-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4cd964, #ffcc00, #ff3b30);
            border-radius: 3px;
            transition: width 0.05s ease;
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 15px 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .info-row:last-child {
            margin-bottom: 0;
        }

        .info-label {
            font-size: 0.8rem;
            opacity: 0.8;
        }

        .info-value {
            font-size: 1.1rem;
            font-weight: bold;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 10px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .status-stopped { background: rgba(255, 255, 255, 0.2); }
        .status-waiting { background: rgba(255, 204, 0, 0.3); border: 1px solid rgba(255, 204, 0, 0.6); }
        .status-learning { background: rgba(100, 149, 237, 0.3); border: 1px solid rgba(100, 149, 237, 0.6); }
        .status-counting { background: rgba(76, 217, 100, 0.3); border: 1px solid rgba(76, 217, 100, 0.6); }

        .control-button {
            width: 100%;
            padding: 18px;
            font-size: 1.1rem;
            font-weight: 600;
            border: none;
            border-radius: 16px;
            background: white;
            color: #667eea;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
        }

        .control-button:active {
            transform: scale(0.98);
        }

        .control-button.listening {
            background: #ff3b30;
            color: white;
        }

        .instructions {
            text-align: center;
            margin-top: 15px;
            font-size: 0.75rem;
            opacity: 0.7;
            line-height: 1.4;
        }

        @media (max-width: 480px) {
            h1 { font-size: 1.5rem; }
            .beat-indicator { width: 140px; height: 140px; font-size: 3rem; }
            .beat-dot { width: 25px; height: 25px; font-size: 0.6rem; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>8-Count</h1>
        <p class="subtitle">Predictive counting with tempo lock</p>

        <div class="beat-indicator" id="beatIndicator">
            <span id="currentCount">-</span>
        </div>

        <div class="phrase-display" id="phraseDisplay">
            <div class="beat-dot accent-beat" data-beat="1">1</div>
            <div class="beat-dot" data-beat="2">2</div>
            <div class="beat-dot" data-beat="3">3</div>
            <div class="beat-dot" data-beat="4">4</div>
            <div class="beat-dot" data-beat="5">5</div>
            <div class="beat-dot" data-beat="6">6</div>
            <div class="beat-dot" data-beat="7">7</div>
            <div class="beat-dot" data-beat="8">8</div>
        </div>

        <div id="controlsContainer" style="display: none;">
            <!-- Volume meter -->
            <div class="volume-container">
                <div class="volume-label">
                    <span>Volume</span>
                    <span id="volumePercent">0%</span>
                </div>
                <div class="volume-meter">
                    <div class="volume-bar" id="volumeBar"></div>
                </div>
            </div>

            <!-- Sensitivity slider -->
            <div class="slider-container">
                <div class="slider-label">
                    <span>Beat Sensitivity</span>
                    <span class="slider-value" id="sensitivityValue">1.4</span>
                </div>
                <input type="range" min="1.1" max="2.0" step="0.1" value="1.4" id="sensitivitySlider">
            </div>

            <!-- Beats for prediction slider -->
            <div class="slider-container">
                <div class="slider-label">
                    <span>Beats to lock tempo</span>
                    <span class="slider-value" id="lockBeatsValue">4</span>
                </div>
                <input type="range" min="2" max="8" step="1" value="4" id="lockBeatsSlider">
            </div>
        </div>

        <div class="info-panel">
            <div class="info-row">
                <span class="info-label">Status</span>
                <span class="status-badge status-stopped" id="statusBadge">Stopped</span>
            </div>
            <div class="info-row">
                <span class="info-label">BPM</span>
                <span class="info-value" id="bpmValue">--</span>
            </div>
            <div class="info-row">
                <span class="info-label">Mode</span>
                <span class="info-value" id="modeInfo">--</span>
            </div>
        </div>

        <button class="control-button" id="controlButton">Start Listening</button>

        <p class="instructions">
            Learns tempo from first beats, then counts predictively.
            Only adjusts if timing changes consistently.
        </p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/meyda@5.6.0/dist/web/meyda.min.js"></script>
    <script>
        class BeatCounter {
            constructor() {
                this.isListening = false;
                this.audioContext = null;
                this.microphone = null;
                this.meydaAnalyzer = null;

                // Settings
                this.sensitivity = 1.4;
                this.lockBeats = 4; // How many consistent beats needed to lock/adjust tempo

                // Volume
                this.volumeHistory = [];
                this.smoothedVolume = 0;
                this.maxObservedVolume = 0.05;

                // Beat detection
                this.energyHistory = [];
                this.lastBeatTime = 0;

                // Tempo tracking
                this.beatTimes = []; // Actual detected beat times
                this.beatIntervals = []; // Intervals between beats
                this.lockedBPM = 0; // Locked tempo
                this.lockedInterval = 0; // Interval in seconds

                // Predictive counting
                this.isTempoLocked = false;
                this.countTimer = null;
                this.currentCount = 0; // 0-7
                this.nextScheduledTime = 0;

                // Phrase tracking
                this.phraseStartTime = 0;

                // Voice
                this.synth = window.speechSynthesis;

                // UI
                this.controlButton = document.getElementById('controlButton');
                this.statusBadge = document.getElementById('statusBadge');
                this.beatIndicator = document.getElementById('beatIndicator');
                this.currentCountEl = document.getElementById('currentCount');
                this.bpmValue = document.getElementById('bpmValue');
                this.modeInfo = document.getElementById('modeInfo');
                this.volumeBar = document.getElementById('volumeBar');
                this.volumePercent = document.getElementById('volumePercent');
                this.controlsContainer = document.getElementById('controlsContainer');
                this.sensitivitySlider = document.getElementById('sensitivitySlider');
                this.sensitivityValue = document.getElementById('sensitivityValue');
                this.lockBeatsSlider = document.getElementById('lockBeatsSlider');
                this.lockBeatsValue = document.getElementById('lockBeatsValue');
                this.beatDots = document.querySelectorAll('.beat-dot');

                this.bindEvents();
            }

            bindEvents() {
                this.controlButton.addEventListener('click', () => {
                    if (this.isListening) {
                        this.stop();
                    } else {
                        this.start();
                    }
                });

                this.sensitivitySlider.addEventListener('input', (e) => {
                    this.sensitivity = parseFloat(e.target.value);
                    this.sensitivityValue.textContent = this.sensitivity.toFixed(1);
                });

                this.lockBeatsSlider.addEventListener('input', (e) => {
                    this.lockBeats = parseInt(e.target.value);
                    this.lockBeatsValue.textContent = this.lockBeats;
                });
            }

            async start() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
                    });

                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.microphone = this.audioContext.createMediaStreamSource(stream);

                    this.meydaAnalyzer = Meyda.createMeydaAnalyzer({
                        audioContext: this.audioContext,
                        source: this.microphone,
                        bufferSize: 512,
                        featureExtractors: ['rms', 'energy'],
                        callback: (features) => this.processAudio(features)
                    });

                    this.meydaAnalyzer.start();
                    this.resetState();

                    this.isListening = true;
                    this.controlsContainer.style.display = 'block';
                    this.updateUI();
                    this.updateStatus('Learning tempo...', 'learning');
                    this.modeInfo.textContent = 'Listening';
                    this.beatIndicator.classList.add('waiting');

                } catch (error) {
                    console.error('Error:', error);
                    alert('Please allow microphone access.');
                }
            }

            stop() {
                if (this.countTimer) {
                    clearTimeout(this.countTimer);
                    this.countTimer = null;
                }
                if (this.meydaAnalyzer) this.meydaAnalyzer.stop();
                if (this.microphone && this.microphone.mediaStream) {
                    this.microphone.mediaStream.getTracks().forEach(t => t.stop());
                }
                if (this.audioContext) this.audioContext.close();

                this.isListening = false;
                this.controlsContainer.style.display = 'none';
                this.updateUI();
                this.updateStatus('Stopped', 'stopped');
                this.currentCountEl.textContent = '-';
                this.bpmValue.textContent = '--';
                this.modeInfo.textContent = '--';
                this.beatIndicator.classList.remove('waiting', 'accent', 'pulse');
                this.clearDots();
            }

            resetState() {
                this.volumeHistory = [];
                this.smoothedVolume = 0;
                this.maxObservedVolume = 0.05;
                this.energyHistory = [];
                this.lastBeatTime = 0;
                this.beatTimes = [];
                this.beatIntervals = [];
                this.lockedBPM = 0;
                this.lockedInterval = 0;
                this.isTempoLocked = false;
                this.currentCount = 0;
                this.nextScheduledTime = 0;
                this.phraseStartTime = 0;
                if (this.countTimer) {
                    clearTimeout(this.countTimer);
                    this.countTimer = null;
                }
            }

            processAudio(features) {
                if (!features || !this.isListening) return;

                const now = this.audioContext.currentTime;
                const rms = features.rms || 0;

                // Smooth volume
                this.volumeHistory.push(rms);
                if (this.volumeHistory.length > 10) this.volumeHistory.shift();
                this.smoothedVolume = this.volumeHistory.reduce((a, b) => a + b, 0) / this.volumeHistory.length;

                if (this.smoothedVolume > this.maxObservedVolume) {
                    this.maxObservedVolume = this.smoothedVolume;
                }

                this.updateVolumeDisplay();

                // Beat detection (always running to track tempo changes)
                this.energyHistory.push(rms);
                if (this.energyHistory.length > 25) this.energyHistory.shift();
                if (this.energyHistory.length < 4) return;

                const avgEnergy = this.energyHistory.reduce((a, b) => a + b, 0) / this.energyHistory.length;
                const threshold = avgEnergy * this.sensitivity;
                const timeSinceLast = now - this.lastBeatTime;

                // Detect beat
                if (rms > threshold && timeSinceLast > 0.15) {
                    this.onBeatDetected(now);
                }
            }

            onBeatDetected(time) {
                // Record beat time
                if (this.lastBeatTime > 0) {
                    const interval = time - this.lastBeatTime;
                    if (interval > 0.2 && interval < 1.5) { // 40-300 BPM range
                        this.beatIntervals.push(interval);
                        this.beatTimes.push(time);

                        // Keep rolling window
                        if (this.beatIntervals.length > 16) {
                            this.beatIntervals.shift();
                            this.beatTimes.shift();
                        }

                        this.checkTempo();
                    }
                }
                this.lastBeatTime = time;
            }

            checkTempo() {
                if (this.beatIntervals.length < this.lockBeats) return;

                // Get last N intervals
                const recentIntervals = this.beatIntervals.slice(-this.lockBeats);

                // Calculate median of recent intervals
                const sorted = [...recentIntervals].sort((a, b) => a - b);
                const median = sorted[Math.floor(sorted.length / 2)];

                // Check consistency - all intervals should be within 15% of median
                const tolerance = 0.15;
                const allConsistent = recentIntervals.every(i =>
                    Math.abs(i - median) / median < tolerance
                );

                if (!allConsistent) {
                    // Beats are inconsistent - if we were locked, check if we need to unlock
                    if (this.isTempoLocked) {
                        // Check if last N beats are consistently different from locked tempo
                        const avgRecent = recentIntervals.reduce((a, b) => a + b, 0) / recentIntervals.length;
                        const drift = Math.abs(avgRecent - this.lockedInterval) / this.lockedInterval;

                        if (drift > 0.1) { // More than 10% drift
                            // Tempo has changed significantly - relearn
                            this.isTempoLocked = false;
                            if (this.countTimer) {
                                clearTimeout(this.countTimer);
                                this.countTimer = null;
                            }
                            this.updateStatus('Relearning...', 'learning');
                            this.modeInfo.textContent = 'Adjusting';
                        }
                    }
                    return;
                }

                // Intervals are consistent
                const newBPM = 60 / median;

                if (!this.isTempoLocked) {
                    // Lock tempo and start predictive counting
                    this.lockedBPM = newBPM;
                    this.lockedInterval = median;
                    this.isTempoLocked = true;
                    this.currentCount = 0;
                    this.phraseStartTime = this.beatTimes[this.beatTimes.length - 1];

                    this.updateStatus('Counting', 'counting');
                    this.modeInfo.textContent = 'Locked';
                    this.bpmValue.textContent = Math.round(this.lockedBPM);
                    this.beatIndicator.classList.remove('waiting');

                    // Start the count immediately, then schedule next
                    this.doCount();
                    this.scheduleNextCount();
                } else {
                    // Already locked - check if we should adjust
                    const drift = Math.abs(median - this.lockedInterval) / this.lockedInterval;

                    if (drift > 0.05) { // More than 5% change
                        // Smoothly adjust tempo
                        this.lockedInterval = this.lockedInterval * 0.7 + median * 0.3;
                        this.lockedBPM = 60 / this.lockedInterval;
                        this.bpmValue.textContent = Math.round(this.lockedBPM);

                        // Reschedule if needed
                        this.rescheduleCount();
                    }
                }
            }

            scheduleNextCount() {
                if (!this.isTempoLocked || !this.isListening) return;

                const now = this.audioContext.currentTime;
                const timeSincePhrase = now - this.phraseStartTime;
                const beatInPhrase = timeSincePhrase / this.lockedInterval;
                const nextBeatNumber = Math.ceil(beatInPhrase);
                const timeToNext = (nextBeatNumber * this.lockedInterval) - timeSincePhrase;

                // Convert to milliseconds and schedule
                const delayMs = Math.max(10, timeToNext * 1000);

                this.countTimer = setTimeout(() => {
                    if (this.isListening && this.isTempoLocked) {
                        this.currentCount = nextBeatNumber % 8;
                        this.doCount();
                        this.scheduleNextCount();
                    }
                }, delayMs);
            }

            rescheduleCount() {
                if (this.countTimer) {
                    clearTimeout(this.countTimer);
                }
                this.scheduleNextCount();
            }

            doCount() {
                const displayCount = this.currentCount + 1; // 1-8

                // Visual
                this.currentCountEl.textContent = displayCount;
                this.beatIndicator.classList.remove('accent');
                if (displayCount === 1) {
                    this.beatIndicator.classList.add('accent');
                }

                this.beatIndicator.classList.add('pulse');
                setTimeout(() => {
                    this.beatIndicator.classList.remove('pulse');
                }, 80);

                this.updateDots(this.currentCount);

                // Speak
                this.speakCount(displayCount);
            }

            updateDots(currentIndex) {
                this.beatDots.forEach((dot, i) => {
                    dot.classList.remove('current');
                    if (i === currentIndex) {
                        dot.classList.add('current');
                    }
                });
            }

            clearDots() {
                this.beatDots.forEach(dot => dot.classList.remove('current'));
            }

            speakCount(count) {
                if (this.synth.speaking) {
                    this.synth.cancel();
                }

                const utterance = new SpeechSynthesisUtterance(count.toString());
                utterance.rate = 2.2;
                utterance.volume = 0.9;
                utterance.pitch = count === 1 ? 1.3 : 1.0;

                this.synth.speak(utterance);
            }

            updateVolumeDisplay() {
                const scaled = this.smoothedVolume / Math.max(this.maxObservedVolume, 0.01);
                const percent = Math.min(100, scaled * 100);
                this.volumeBar.style.width = percent + '%';
                this.volumePercent.textContent = Math.round(percent) + '%';
            }

            updateUI() {
                if (this.isListening) {
                    this.controlButton.textContent = 'Stop';
                    this.controlButton.classList.add('listening');
                } else {
                    this.controlButton.textContent = 'Start Listening';
                    this.controlButton.classList.remove('listening');
                }
            }

            updateStatus(text, type) {
                this.statusBadge.textContent = text;
                this.statusBadge.className = 'status-badge status-' + type;
            }
        }

        window.addEventListener('load', () => {
            new BeatCounter();
        });
    </script>
</body>
</html>
