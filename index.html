<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>8-Count Beat Counter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: white;
        }

        .container {
            max-width: 600px;
            width: 100%;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .subtitle {
            text-align: center;
            margin-bottom: 20px;
            opacity: 0.9;
            font-size: 0.9rem;
        }

        .panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-btn {
            width: 100%;
            padding: 15px;
            font-size: 1rem;
            font-weight: 600;
            border: 2px dashed rgba(255,255,255,0.4);
            border-radius: 12px;
            background: rgba(255,255,255,0.1);
            color: white;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .file-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: rgba(255,255,255,0.6);
        }

        .song-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 15px;
        }

        .song-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .song-item:hover {
            background: rgba(255,255,255,0.2);
        }

        .song-item.selected {
            background: rgba(76, 217, 100, 0.3);
            border: 1px solid rgba(76, 217, 100, 0.6);
        }

        .song-item.processing {
            background: rgba(255, 204, 0, 0.3);
            border: 1px solid rgba(255, 204, 0, 0.6);
        }

        .song-item.ready {
            background: rgba(76, 217, 100, 0.2);
        }

        .song-name {
            font-weight: 500;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
        }

        .song-status {
            font-size: 0.75rem;
            opacity: 0.8;
            margin-left: 10px;
        }

        .song-bpm {
            font-size: 0.85rem;
            font-weight: 600;
            color: #4cd964;
            margin-left: 10px;
        }

        /* Beat indicator */
        .beat-indicator {
            width: 160px;
            height: 160px;
            margin: 0 auto 20px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: 4px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4rem;
            font-weight: bold;
            transition: transform 0.08s ease, background 0.08s ease;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
        }

        .beat-indicator.pulse {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.6);
        }

        .beat-indicator.accent {
            background: rgba(255, 215, 0, 0.4);
            border-color: rgba(255, 215, 0, 0.8);
        }

        /* Beat dots */
        .phrase-display {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 20px;
        }

        .beat-dot {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
            transition: all 0.1s ease;
        }

        .beat-dot.current {
            background: rgba(255, 255, 255, 0.6);
            transform: scale(1.2);
        }

        .beat-dot.accent-beat {
            border: 2px solid rgba(255, 215, 0, 0.8);
        }

        /* Progress bar */
        .progress-container {
            margin-bottom: 15px;
        }

        .progress-bar {
            height: 8px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4cd964, #5ac8fa);
            border-radius: 4px;
            transition: width 0.1s linear;
        }

        .time-display {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin-top: 5px;
            opacity: 0.8;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .control-btn {
            flex: 1;
            padding: 15px;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .play-btn {
            background: #4cd964;
            color: white;
        }

        .play-btn:hover {
            background: #3cb553;
        }

        .play-btn:disabled {
            background: rgba(255,255,255,0.2);
            cursor: not-allowed;
        }

        .play-btn.playing {
            background: #ff9500;
        }

        .stop-btn {
            background: #ff3b30;
            color: white;
            flex: 0.5;
        }

        .stop-btn:hover {
            background: #e0352b;
        }

        /* Info panel */
        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-label {
            font-size: 0.85rem;
            opacity: 0.8;
        }

        .info-value {
            font-size: 1rem;
            font-weight: 600;
        }

        /* Volume slider */
        .slider-container {
            margin-top: 15px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin-bottom: 8px;
            opacity: 0.9;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        /* Processing overlay */
        .processing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            display: none;
        }

        .processing-overlay.active {
            display: flex;
        }

        .processing-content {
            text-align: center;
            padding: 30px;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .processing-text {
            font-size: 1.1rem;
            margin-bottom: 10px;
        }

        .processing-detail {
            font-size: 0.85rem;
            opacity: 0.7;
        }

        .instructions {
            text-align: center;
            font-size: 0.75rem;
            opacity: 0.7;
            line-height: 1.4;
            margin-top: 15px;
        }

        @media (max-width: 480px) {
            h1 { font-size: 1.5rem; }
            .beat-indicator { width: 120px; height: 120px; font-size: 3rem; }
            .beat-dot { width: 28px; height: 28px; font-size: 0.7rem; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>8-Count</h1>
        <p class="subtitle">Load songs, detect beats, count along</p>

        <!-- File Selection Panel -->
        <div class="panel">
            <div class="file-input-wrapper">
                <div class="file-btn" id="fileBtn">Click or drop MP3 files here</div>
                <input type="file" id="fileInput" accept="audio/*" multiple>
            </div>
            <div class="song-list" id="songList"></div>
        </div>

        <!-- Player Panel (hidden until song selected) -->
        <div class="panel" id="playerPanel" style="display: none;">
            <div class="beat-indicator" id="beatIndicator">
                <span id="currentCount">-</span>
            </div>

            <div class="phrase-display" id="phraseDisplay">
                <div class="beat-dot accent-beat" data-beat="1">1</div>
                <div class="beat-dot" data-beat="2">2</div>
                <div class="beat-dot" data-beat="3">3</div>
                <div class="beat-dot" data-beat="4">4</div>
                <div class="beat-dot" data-beat="5">5</div>
                <div class="beat-dot" data-beat="6">6</div>
                <div class="beat-dot" data-beat="7">7</div>
                <div class="beat-dot" data-beat="8">8</div>
            </div>

            <div class="progress-container">
                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="time-display">
                    <span id="currentTime">0:00</span>
                    <span id="totalTime">0:00</span>
                </div>
            </div>

            <div class="controls">
                <button class="control-btn play-btn" id="playBtn" disabled>Process First</button>
                <button class="control-btn stop-btn" id="stopBtn">Stop</button>
            </div>

            <div class="info-row">
                <span class="info-label">BPM</span>
                <span class="info-value" id="bpmValue">--</span>
            </div>
            <div class="info-row">
                <span class="info-label">Beats Detected</span>
                <span class="info-value" id="beatsValue">--</span>
            </div>
            <div class="info-row">
                <span class="info-label">8-Count Phrases</span>
                <span class="info-value" id="phrasesValue">--</span>
            </div>

            <div class="slider-container">
                <div class="slider-label">
                    <span>Voice Volume</span>
                    <span id="voiceVolValue">70%</span>
                </div>
                <input type="range" min="0" max="100" value="70" id="voiceVolSlider">
            </div>

            <div class="slider-container">
                <div class="slider-label">
                    <span>Music Volume</span>
                    <span id="musicVolValue">100%</span>
                </div>
                <input type="range" min="0" max="100" value="100" id="musicVolSlider">
            </div>
        </div>

        <p class="instructions">
            Select MP3 files to analyze. The app will detect beats, find 8-count phrases, and count along with the music.
        </p>
    </div>

    <!-- Processing Overlay -->
    <div class="processing-overlay" id="processingOverlay">
        <div class="processing-content">
            <div class="spinner"></div>
            <div class="processing-text" id="processingText">Processing...</div>
            <div class="processing-detail" id="processingDetail">Analyzing audio</div>
        </div>
    </div>

    <script>
        class BeatCounterApp {
            constructor() {
                this.audioContext = null;
                this.songs = []; // {name, file, audioBuffer, beats, bpm, phraseOffset, processed}
                this.currentSong = null;
                this.isPlaying = false;
                this.sourceNode = null;
                this.gainNode = null;
                this.startTime = 0;
                this.pauseTime = 0;
                this.animationFrame = null;
                this.scheduledCounts = [];
                this.currentCount = 0;

                // Voice
                this.synth = window.speechSynthesis;
                this.selectedVoice = null;
                this.voiceVolume = 0.7;
                this.musicVolume = 1.0;

                // UI Elements
                this.fileInput = document.getElementById('fileInput');
                this.fileBtn = document.getElementById('fileBtn');
                this.songList = document.getElementById('songList');
                this.playerPanel = document.getElementById('playerPanel');
                this.playBtn = document.getElementById('playBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.progressBar = document.getElementById('progressBar');
                this.progressFill = document.getElementById('progressFill');
                this.currentTimeEl = document.getElementById('currentTime');
                this.totalTimeEl = document.getElementById('totalTime');
                this.beatIndicator = document.getElementById('beatIndicator');
                this.currentCountEl = document.getElementById('currentCount');
                this.bpmValue = document.getElementById('bpmValue');
                this.beatsValue = document.getElementById('beatsValue');
                this.phrasesValue = document.getElementById('phrasesValue');
                this.voiceVolSlider = document.getElementById('voiceVolSlider');
                this.voiceVolValue = document.getElementById('voiceVolValue');
                this.musicVolSlider = document.getElementById('musicVolSlider');
                this.musicVolValue = document.getElementById('musicVolValue');
                this.processingOverlay = document.getElementById('processingOverlay');
                this.processingText = document.getElementById('processingText');
                this.processingDetail = document.getElementById('processingDetail');
                this.beatDots = document.querySelectorAll('.beat-dot');

                this.bindEvents();
                this.selectBestVoice();
            }

            bindEvents() {
                // File input
                this.fileInput.addEventListener('change', (e) => this.handleFiles(e.target.files));

                // Drag and drop
                this.fileBtn.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    this.fileBtn.style.borderColor = 'rgba(255,255,255,0.8)';
                    this.fileBtn.style.background = 'rgba(255,255,255,0.2)';
                });

                this.fileBtn.addEventListener('dragleave', () => {
                    this.fileBtn.style.borderColor = 'rgba(255,255,255,0.4)';
                    this.fileBtn.style.background = 'rgba(255,255,255,0.1)';
                });

                this.fileBtn.addEventListener('drop', (e) => {
                    e.preventDefault();
                    this.fileBtn.style.borderColor = 'rgba(255,255,255,0.4)';
                    this.fileBtn.style.background = 'rgba(255,255,255,0.1)';
                    this.handleFiles(e.dataTransfer.files);
                });

                // Playback controls
                this.playBtn.addEventListener('click', () => this.togglePlay());
                this.stopBtn.addEventListener('click', () => this.stop());

                // Progress bar seek
                this.progressBar.addEventListener('click', (e) => {
                    if (!this.currentSong || !this.currentSong.processed) return;
                    const rect = this.progressBar.getBoundingClientRect();
                    const percent = (e.clientX - rect.left) / rect.width;
                    this.seek(percent * this.currentSong.audioBuffer.duration);
                });

                // Volume sliders
                this.voiceVolSlider.addEventListener('input', (e) => {
                    this.voiceVolume = e.target.value / 100;
                    this.voiceVolValue.textContent = e.target.value + '%';
                });

                this.musicVolSlider.addEventListener('input', (e) => {
                    this.musicVolume = e.target.value / 100;
                    this.musicVolValue.textContent = e.target.value + '%';
                    if (this.gainNode) {
                        this.gainNode.gain.value = this.musicVolume;
                    }
                });

                // Voice selection
                if (this.synth.onvoiceschanged !== undefined) {
                    this.synth.onvoiceschanged = () => this.selectBestVoice();
                }
            }

            async handleFiles(files) {
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                for (const file of files) {
                    if (!file.type.startsWith('audio/')) continue;

                    // Check if already added
                    if (this.songs.find(s => s.name === file.name)) continue;

                    const song = {
                        name: file.name,
                        file: file,
                        audioBuffer: null,
                        beats: [],
                        bpm: 0,
                        processed: false
                    };

                    this.songs.push(song);
                }

                this.renderSongList();
            }

            renderSongList() {
                this.songList.innerHTML = '';

                for (const song of this.songs) {
                    const item = document.createElement('div');
                    item.className = 'song-item';
                    if (this.currentSong === song) {
                        item.classList.add('selected');
                    }
                    if (song.processed) {
                        item.classList.add('ready');
                    }

                    let statusText = 'Click to process';
                    if (song.processed) {
                        statusText = 'Ready';
                    }

                    item.innerHTML = `
                        <span class="song-name">${song.name}</span>
                        ${song.processed ? `<span class="song-bpm">${song.bpm} BPM</span>` : ''}
                        <span class="song-status">${statusText}</span>
                    `;

                    item.addEventListener('click', () => this.selectSong(song));
                    this.songList.appendChild(item);
                }
            }

            async selectSong(song) {
                this.stop();
                this.currentSong = song;
                this.playerPanel.style.display = 'block';
                this.renderSongList();

                if (!song.processed) {
                    await this.processSong(song);
                }

                this.updatePlayerUI();
            }

            async processSong(song) {
                this.showProcessing('Loading audio...', song.name);

                try {
                    // Load audio buffer
                    const arrayBuffer = await song.file.arrayBuffer();
                    song.audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);

                    this.showProcessing('Analyzing beats...', 'This may take a moment');

                    // Detect beats
                    const analysis = await this.analyzeBeats(song.audioBuffer);
                    song.beats = analysis.beats;
                    song.bpm = analysis.bpm;

                    this.showProcessing('Validating 8-counts...', `Found ${song.beats.length} beats at ${song.bpm} BPM`);

                    // Validate and adjust beats for proper 8-count distribution
                    song.beats = this.validate8Counts(song.beats, song.bpm, song.audioBuffer.duration);

                    this.showProcessing('Finding phrase alignment...', 'Detecting accented beats');

                    // Find where "1" should fall based on accent patterns
                    song.phraseOffset = this.findPhraseAlignment(song.beats, song.audioBuffer);

                    song.processed = true;
                    this.hideProcessing();
                    this.renderSongList();

                } catch (error) {
                    console.error('Error processing song:', error);
                    this.hideProcessing();
                    alert('Error processing audio file: ' + error.message);
                }
            }

            async analyzeBeats(audioBuffer) {
                // Get mono audio data
                const channelData = audioBuffer.getChannelData(0);
                const sampleRate = audioBuffer.sampleRate;

                // Parameters for beat detection
                const hopSize = Math.floor(sampleRate * 0.01); // 10ms hops
                const frameSize = Math.floor(sampleRate * 0.02); // 20ms frames

                // Calculate spectral flux for onset detection
                const fluxValues = [];
                const energyValues = [];
                let prevSpectrum = null;

                // Use smaller FFT for efficiency
                const fftSize = 1024;
                const offlineCtx = new OfflineAudioContext(1, audioBuffer.length, sampleRate);
                const analyser = offlineCtx.createAnalyser();
                analyser.fftSize = fftSize;

                // Process in chunks to calculate flux
                for (let i = 0; i < channelData.length - frameSize; i += hopSize) {
                    // Calculate frame energy
                    let energy = 0;
                    for (let j = 0; j < frameSize; j++) {
                        energy += channelData[i + j] * channelData[i + j];
                    }
                    energy = Math.sqrt(energy / frameSize);
                    energyValues.push(energy);

                    // Simple spectral flux approximation using energy difference
                    if (energyValues.length > 1) {
                        const flux = Math.max(0, energy - energyValues[energyValues.length - 2]);
                        fluxValues.push({ time: i / sampleRate, flux, energy });
                    }
                }

                // Normalize flux values
                const maxFlux = Math.max(...fluxValues.map(f => f.flux));
                fluxValues.forEach(f => f.flux = f.flux / maxFlux);

                // Peak picking with adaptive threshold
                const beats = [];
                const windowSize = 10; // samples for local average
                const threshold = 0.3;
                const minBeatInterval = 0.2; // 300 BPM max

                for (let i = windowSize; i < fluxValues.length - windowSize; i++) {
                    const current = fluxValues[i];

                    // Local average
                    let localAvg = 0;
                    for (let j = i - windowSize; j <= i + windowSize; j++) {
                        localAvg += fluxValues[j].flux;
                    }
                    localAvg /= (windowSize * 2 + 1);

                    // Is this a peak above threshold?
                    const isLocalMax = current.flux > fluxValues[i - 1].flux &&
                                       current.flux > fluxValues[i + 1].flux;
                    const aboveThreshold = current.flux > localAvg + threshold;

                    if (isLocalMax && aboveThreshold) {
                        // Check minimum interval
                        if (beats.length === 0 || current.time - beats[beats.length - 1].time > minBeatInterval) {
                            beats.push({ time: current.time, energy: current.energy });
                        }
                    }
                }

                // Calculate BPM from beat intervals
                const intervals = [];
                for (let i = 1; i < beats.length; i++) {
                    const interval = beats[i].time - beats[i - 1].time;
                    if (interval > 0.25 && interval < 1.5) { // 40-240 BPM range
                        intervals.push(interval);
                    }
                }

                // Find most common interval (histogram approach)
                const bpmHistogram = {};
                for (const interval of intervals) {
                    const bpm = Math.round(60 / interval);
                    // Round to nearest 5 BPM for grouping
                    const roundedBpm = Math.round(bpm / 5) * 5;
                    bpmHistogram[roundedBpm] = (bpmHistogram[roundedBpm] || 0) + 1;
                }

                let bestBpm = 120; // Default
                let bestCount = 0;
                for (const [bpm, count] of Object.entries(bpmHistogram)) {
                    if (count > bestCount) {
                        bestCount = count;
                        bestBpm = parseInt(bpm);
                    }
                }

                // Refine BPM using median of intervals near the detected BPM
                const targetInterval = 60 / bestBpm;
                const nearIntervals = intervals.filter(i =>
                    Math.abs(i - targetInterval) / targetInterval < 0.2
                );

                if (nearIntervals.length > 0) {
                    nearIntervals.sort((a, b) => a - b);
                    const medianInterval = nearIntervals[Math.floor(nearIntervals.length / 2)];
                    bestBpm = Math.round(60 / medianInterval);
                }

                return { beats, bpm: bestBpm };
            }

            validate8Counts(beats, bpm, duration) {
                // Expected interval between beats
                const expectedInterval = 60 / bpm;

                // If we have very few beats, generate them from BPM
                if (beats.length < 16) {
                    console.log('Too few beats detected, generating from BPM');
                    return this.generateBeatsFromBpm(bpm, duration);
                }

                // Find the most likely starting point for phrase alignment
                // by looking at beat energies (louder beats often fall on 1)

                // Calculate average interval from detected beats
                let totalInterval = 0;
                let count = 0;
                for (let i = 1; i < beats.length; i++) {
                    const interval = beats[i].time - beats[i - 1].time;
                    if (Math.abs(interval - expectedInterval) / expectedInterval < 0.3) {
                        totalInterval += interval;
                        count++;
                    }
                }

                const actualInterval = count > 0 ? totalInterval / count : expectedInterval;
                const actualBpm = Math.round(60 / actualInterval);

                console.log(`Detected ${beats.length} beats, calculated interval: ${actualInterval.toFixed(3)}s (${actualBpm} BPM)`);

                // Check beat distribution - are beats evenly spaced?
                const toleratedBeats = [];
                let expectedTime = beats[0].time;

                for (let i = 0; i < beats.length; i++) {
                    const beat = beats[i];

                    // Find nearest expected beat time
                    while (expectedTime < beat.time - actualInterval * 0.4) {
                        expectedTime += actualInterval;
                    }

                    // Is this beat close to an expected time?
                    if (Math.abs(beat.time - expectedTime) < actualInterval * 0.3) {
                        toleratedBeats.push({ time: expectedTime, energy: beat.energy });
                        expectedTime += actualInterval;
                    }
                }

                // If we lost too many beats, regenerate from BPM
                if (toleratedBeats.length < beats.length * 0.5) {
                    console.log('Beat timing too inconsistent, generating from BPM');
                    return this.generateBeatsFromBpm(bpm, duration, beats[0].time);
                }

                // Fill in any missing beats
                const filledBeats = [];
                const startTime = toleratedBeats[0].time;
                const endTime = duration - 0.5; // Stop 0.5s before end

                for (let t = startTime; t < endTime; t += actualInterval) {
                    // Check if we have a detected beat near this time
                    const nearBeat = toleratedBeats.find(b =>
                        Math.abs(b.time - t) < actualInterval * 0.3
                    );

                    filledBeats.push({
                        time: nearBeat ? nearBeat.time : t,
                        energy: nearBeat ? nearBeat.energy : 0.5
                    });
                }

                console.log(`Validated to ${filledBeats.length} beats`);
                return filledBeats;
            }

            generateBeatsFromBpm(bpm, duration, startTime = 0.5) {
                const interval = 60 / bpm;
                const beats = [];

                for (let t = startTime; t < duration - 0.5; t += interval) {
                    beats.push({ time: t, energy: 0.5 });
                }

                return beats;
            }

            findPhraseAlignment(beats, audioBuffer) {
                // Find the best offset (0-7) so that "1" falls on accented beats
                // Strategy: use LOW FREQUENCY energy (bass/kick) which typically hits on beat 1

                if (beats.length < 32) {
                    return 0; // Not enough beats to analyze
                }

                const channelData = audioBuffer.getChannelData(0);
                const sampleRate = audioBuffer.sampleRate;

                // Skip first 20 beats (potential intro)
                const startBeat = 20;
                const analysisBeats = beats.slice(startBeat);

                // Simple low-pass filter to extract bass frequencies (~60-150Hz)
                // We'll measure energy after applying a moving average (crude low-pass)
                const windowMs = 100; // 100ms window
                const windowSamples = Math.floor(sampleRate * windowMs / 1000);

                // For low-frequency detection, we look at the smoothed signal
                // A simple approach: measure how much the signal swings (peak-to-peak) in bass range
                const beatBassEnergy = [];

                for (let idx = 0; idx < analysisBeats.length; idx++) {
                    const beat = analysisBeats[idx];
                    const centerSample = Math.floor(beat.time * sampleRate);
                    const start = Math.max(0, centerSample - windowSamples / 2);
                    const end = Math.min(channelData.length, centerSample + windowSamples / 2);

                    // Apply simple low-pass by averaging chunks (extracts bass)
                    const chunkSize = Math.floor(sampleRate / 150); // ~150Hz cutoff
                    let bassEnergy = 0;
                    let chunks = 0;

                    for (let i = start; i < end - chunkSize; i += chunkSize) {
                        let chunkSum = 0;
                        for (let j = 0; j < chunkSize; j++) {
                            chunkSum += channelData[i + j];
                        }
                        const chunkAvg = chunkSum / chunkSize;
                        bassEnergy += chunkAvg * chunkAvg;
                        chunks++;
                    }

                    bassEnergy = chunks > 0 ? Math.sqrt(bassEnergy / chunks) : 0;
                    beatBassEnergy.push({ index: startBeat + idx, bass: bassEnergy });
                }

                // Find average bass energy
                const avgBass = beatBassEnergy.reduce((sum, b) => sum + b.bass, 0) / beatBassEnergy.length;

                // Find beats with above-average bass (bass drum hits)
                const bassHits = beatBassEnergy.filter(b => b.bass > avgBass * 1.1);

                // Count which position bass hits fall on
                const positionCounts = [0, 0, 0, 0, 0, 0, 0, 0];
                for (const hit of bassHits) {
                    const position = hit.index % 8;
                    positionCounts[position]++;
                }

                // Find which position has the most bass hits - this should be beat 1
                let maxCount = 0;
                let bassPosition = 0;
                for (let i = 0; i < 8; i++) {
                    if (positionCounts[i] > maxCount) {
                        maxCount = positionCounts[i];
                        bassPosition = i;
                    }
                }

                // The offset needed to make bassPosition become position 0 (beat 1)
                const bestOffset = (8 - bassPosition) % 8;

                console.log(`Bass hit position counts:`, positionCounts.map((c, i) => `${i}:${c}`).join(', '));
                console.log(`Most bass at position ${bassPosition}, using offset ${bestOffset}`);

                return bestOffset;
            }

            updatePlayerUI() {
                const song = this.currentSong;
                if (!song) return;

                if (song.processed) {
                    this.playBtn.disabled = false;
                    this.playBtn.textContent = 'Play with Counting';
                    this.bpmValue.textContent = song.bpm;
                    this.beatsValue.textContent = song.beats.length;
                    this.phrasesValue.textContent = Math.floor(song.beats.length / 8);
                    this.totalTimeEl.textContent = this.formatTime(song.audioBuffer.duration);
                } else {
                    this.playBtn.disabled = true;
                    this.playBtn.textContent = 'Processing...';
                    this.bpmValue.textContent = '--';
                    this.beatsValue.textContent = '--';
                    this.phrasesValue.textContent = '--';
                }

                this.currentCountEl.textContent = '-';
                this.progressFill.style.width = '0%';
                this.currentTimeEl.textContent = '0:00';
            }

            togglePlay() {
                if (this.isPlaying) {
                    this.pause();
                } else {
                    this.play();
                }
            }

            async play() {
                if (!this.currentSong || !this.currentSong.processed) return;

                // Resume audio context if suspended
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }

                // Create source and gain nodes
                this.sourceNode = this.audioContext.createBufferSource();
                this.sourceNode.buffer = this.currentSong.audioBuffer;

                this.gainNode = this.audioContext.createGain();
                this.gainNode.gain.value = this.musicVolume;

                this.sourceNode.connect(this.gainNode);
                this.gainNode.connect(this.audioContext.destination);

                // Calculate start position
                const offset = this.pauseTime;
                this.startTime = this.audioContext.currentTime - offset;

                this.sourceNode.start(0, offset);
                this.isPlaying = true;

                this.playBtn.textContent = 'Pause';
                this.playBtn.classList.add('playing');

                // Schedule all the counts
                this.scheduleAllCounts(offset);

                // Start animation loop
                this.updatePlayback();

                // Handle song end
                this.sourceNode.onended = () => {
                    if (this.isPlaying) {
                        this.stop();
                    }
                };
            }

            pause() {
                if (!this.isPlaying) return;

                this.pauseTime = this.audioContext.currentTime - this.startTime;
                this.sourceNode.stop();
                this.isPlaying = false;

                // Cancel scheduled speech
                this.synth.cancel();
                this.clearScheduledCounts();

                this.playBtn.textContent = 'Resume';
                this.playBtn.classList.remove('playing');

                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                }
            }

            stop() {
                if (this.sourceNode) {
                    try {
                        this.sourceNode.stop();
                    } catch (e) {}
                }

                this.isPlaying = false;
                this.pauseTime = 0;

                this.synth.cancel();
                this.clearScheduledCounts();

                this.playBtn.textContent = 'Play with Counting';
                this.playBtn.classList.remove('playing');

                this.progressFill.style.width = '0%';
                this.currentTimeEl.textContent = '0:00';
                this.currentCountEl.textContent = '-';
                this.beatIndicator.classList.remove('pulse', 'accent');
                this.clearDots();

                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                }
            }

            seek(time) {
                const wasPlaying = this.isPlaying;

                if (this.isPlaying) {
                    this.sourceNode.stop();
                    this.synth.cancel();
                    this.clearScheduledCounts();
                }

                this.pauseTime = Math.max(0, Math.min(time, this.currentSong.audioBuffer.duration));
                this.isPlaying = false;

                if (wasPlaying) {
                    this.play();
                } else {
                    this.progressFill.style.width = (this.pauseTime / this.currentSong.audioBuffer.duration * 100) + '%';
                    this.currentTimeEl.textContent = this.formatTime(this.pauseTime);
                }
            }

            scheduleAllCounts(startOffset) {
                this.clearScheduledCounts();

                const beats = this.currentSong.beats;
                const phraseOffset = this.currentSong.phraseOffset || 0;
                const audioContextTime = this.audioContext.currentTime;

                for (let i = 0; i < beats.length; i++) {
                    const beat = beats[i];
                    const beatTime = beat.time - startOffset;

                    if (beatTime < 0) continue; // Skip past beats

                    // Apply phrase offset so "1" falls on accented beats
                    const count = ((i + phraseOffset) % 8) + 1; // 1-8
                    const triggerTime = audioContextTime + beatTime;

                    // Schedule the count
                    const timeout = setTimeout(() => {
                        this.triggerCount(count);
                    }, beatTime * 1000);

                    this.scheduledCounts.push(timeout);
                }
            }

            clearScheduledCounts() {
                for (const timeout of this.scheduledCounts) {
                    clearTimeout(timeout);
                }
                this.scheduledCounts = [];
            }

            triggerCount(count) {
                this.currentCount = count;

                // Update visual
                this.currentCountEl.textContent = count;
                this.beatIndicator.classList.remove('accent');
                if (count === 1) {
                    this.beatIndicator.classList.add('accent');
                }

                this.beatIndicator.classList.add('pulse');
                setTimeout(() => this.beatIndicator.classList.remove('pulse'), 80);

                this.updateDots(count - 1);

                // Speak the count
                this.speakCount(count);
            }

            speakCount(count) {
                if (this.synth.speaking) {
                    this.synth.cancel();
                }

                const utterance = new SpeechSynthesisUtterance(count.toString());

                if (this.selectedVoice) {
                    utterance.voice = this.selectedVoice;
                }

                utterance.rate = 1.5;
                utterance.volume = this.voiceVolume;
                utterance.pitch = count === 1 ? 1.1 : 0.95;

                this.synth.speak(utterance);
            }

            updatePlayback() {
                if (!this.isPlaying) return;

                const currentTime = this.audioContext.currentTime - this.startTime;
                const duration = this.currentSong.audioBuffer.duration;

                const percent = (currentTime / duration) * 100;
                this.progressFill.style.width = percent + '%';
                this.currentTimeEl.textContent = this.formatTime(currentTime);

                this.animationFrame = requestAnimationFrame(() => this.updatePlayback());
            }

            updateDots(index) {
                this.beatDots.forEach((dot, i) => {
                    dot.classList.remove('current');
                    if (i === index) {
                        dot.classList.add('current');
                    }
                });
            }

            clearDots() {
                this.beatDots.forEach(dot => dot.classList.remove('current'));
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            selectBestVoice() {
                const voices = this.synth.getVoices();
                if (voices.length === 0) return;

                const preferred = ['Samantha', 'Karen', 'Moira', 'Tessa', 'Fiona', 'Daniel', 'Google'];

                for (const name of preferred) {
                    const voice = voices.find(v => v.name.includes(name));
                    if (voice) {
                        this.selectedVoice = voice;
                        return;
                    }
                }

                const englishVoice = voices.find(v => v.lang.startsWith('en'));
                if (englishVoice) {
                    this.selectedVoice = englishVoice;
                }
            }

            showProcessing(text, detail) {
                this.processingText.textContent = text;
                this.processingDetail.textContent = detail;
                this.processingOverlay.classList.add('active');
            }

            hideProcessing() {
                this.processingOverlay.classList.remove('active');
            }
        }

        window.addEventListener('load', () => {
            new BeatCounterApp();
        });
    </script>
</body>
</html>
